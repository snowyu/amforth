<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [

<!ENTITY REFCARD SYSTEM "refcard.xml">

]>

<book>
   <bookinfo>
      <title>amforth - Forth for AVR ATmega mico controller</title>
      <titleabbrev>amforth 2.5</titleabbrev>
      <author>
         <personname>
            <firstname>Matthias</firstname>
            <surname>Trute</surname>
         </personname>
         <email>mtrute@users.sourceforge.net</email>
      </author>

      <pubdate>2007</pubdate>
      <copyright>
         <year>2007</year>
         <holder>Matthias Trute</holder>
      </copyright>
   </bookinfo>
   <toc />
   <chapter id="Overview">
      <title>Overview</title>
      <sect1 id="Introduction">
         <title>Introduction</title>
         <para>
            amforth is a Forth system for the AVR Atmega micro
            controller family. It works on the controller itself and
            does not depend on any additional hard- or software.
         </para>

         <para>
            amforth implements a large subset of the Forth standard
            ANS94. Most of the CORE words and a varying number of words
	    from the additional word sets are implemented. The word 
	    set used in an actual implementation can easily be changed.
         </para>

         <para>
            The dictionary resides in the flash memory. The build-in
            compiler extends it directly.
         </para>

         <para>
            amforth gives full access to (almost) all interrupts. The
            interrupt handler routines are forth words.
         </para>

         <para>
            amforth is published under the GNU General Public License
            version 2.
         </para>

         <para>The name amforth has no special meaning.</para>
      </sect1>
      
      <sect1 id="History">
         <title>History</title>
         <para>
            amforth is a new implementaion. The first code was written
            in the summer of 2006. It is written "from scratch" using
            the atmega assembly language and forth itself. It does not 
	    have a direct relation to any other forth system.
         </para>

         <para>
            The first lines of code were written with the AVR Studio and
            it's simulator. Soon the switch to real hardware (an
            cheap evalation board) and to a linux based development was made.
            The source code can be processed with the AVR Studio and the
            linux avr assembler avra.
         </para>

      </sect1>

      <sect1 id="Hardware">
         <title>Fuses</title>
         <para>
            Amforth uses the self programming features of the ATmegas to
            extend the dictionary. It is ok to use the factory default
            settings plus (!) changes for the oszillator settings. It is
	    recommended to choose a higher speed than the default 1MHz to
	    achieve a stable serial communication. 
         </para>
      </sect1>
   </chapter>

   <chapter id="Sources">
      <title>Source Organisation</title>
      <sect1 id="src_overview">
         <title>Overview</title>
         <para>
            amforth needs an assembler to generate the hex files 
            for flash and EEPROM. That does not mean that
            every word is actually written in assembly language.
            Most of the words are written in forth itself, but are
            precompiled into assembly <emphasis>syntax</emphasis>.
            This solves some chicken-and-egg problems too: compile
            the compiler words.
         </para>
         <para>
            amforth consists of a great number of relativly small source
            files. Nearly all words are in there own source files.
            A number of files are organized with include files, named
            like <filename>dict*.inc</filename>. Currently 3 such files 
	    exists: <filename>dict_minimum</filename>, 
	    <filename>dict_high</filename> and 
	    <filename>dict_compiler</filename>.
         </para>
         <para>
            There are two additional files: <filename>amforth.asm</filename> 
	    and <filename>macros.inc</filename>.
            The first one is the master file and the only one the
            application needs to include. The file <filename>macros.inc</filename> 
	    contains some useful assembler macros which makes the source code
            easier to read.
         </para>
      </sect1>
      <sect1 id="src_core_entry">
         <title>Core system</title>
         <para>
            Thee file <filename>amforth.asm</filename> is the core of amforth. Here are the
            entry code for the microcontroller, and the forth inner
            interpreter with the interrupt service routine. It includes
            the dictionary files and therefor the single word source
            files.
         </para>
         <sect2 id="src_core_dict">
            <title>Dictionary files</title>
            <para>
               The dictionary files have two tasks: For one they include
               the word definition files. The other is the
               placement in the resulting flash layout. The file
               <filename>dict_high.inc</filename> contains all words for the NRWW flash
               section, which cannot be used otherwise. It is
               recommended to maximize the usage of this area, since the
               word <code>i!</code> cannot write to this address range.
            </para>
            <para>
               A useful forth system needs at least the file
               <filename>dict_minimum.inc</filename>. Here are the serial IO and the forth
               interpreter words included.
            </para>
            <para>
               An almost complete forth system with a compiler needs the
               third include file: <filename>dict_compiler.inc</filename>.
	       It includes the typical compiler words.
            </para>
            <para>
               There are a few words left out from the dictionary lists.
               These words are either not always needed or are some
               variants of existing words or simply cannot be included
               to the core system due to size limitations in the NRWW
               section with smaller atmegas.
            </para>
         </sect2>
         <sect2>
            <title>Device Settings</title>
            <para>
               Every Atmega has it own specific settings. They are based
               on the official include files provided by Atmel. 
               The most important settings are the serial IO port (which
               port and which parameters), the interrupt vectors and
               some macros.
            </para>
            <para>
               The last entry is a string with the device name in
               clear text. This string is used within the word <code>VER</code>.
            </para>
         </sect2>
      </sect1>
      <sect1>
         <title>Application Code</title>
         <para>
            Every build of amforth does need an application. There are a
            few sample applications, which can be used either directly
            (such as the AVR Butterfly) or serve as a source for
            inspriration (template application).
         </para>
         <para>
            The structure is basically always the same. First the file
            <filename>macros.asm</filename> has to be included. After that some definitions
            need to set: The size of the Forth buffers, the CPU
            frequency, initial terminal settings etc. Then the device
            specific part needs to be included and as the last step the
            amforth core is included.
         </para>
         <para>
            For a comfortable development cycle the use of a build
	    utility such as make is recommended. The assembler
            needs quite a few settings and the proper order of the
            include directories. The sample applications use the
            standard make, others such as ant or maven can be used as
            well.
         </para>
      </sect1>
   </chapter>
   <chapter id="Architecture">
      <title>Architecture</title>
      <sect1 id="Architectur_Overview">
         <title>Overview</title>

         <para>
            amforth is a 16 bit Forth implementing the indirect
            threading model. The flash memory contains the whole
            dictionary. Some EEPROM cells are used to hold initial
            values. The RAM contains buffers, variables and the stacks.
         </para>

         <para>
            The compiler is a classic compiler without any
            optimization support.
         </para>

         <para>
            amforth uses most of the CPU registers to hold vital data: 
	    The data stack pointer, the instruction pointer,
            the user pointer, and the Top-Of-Stack cell. The hardware
            stack is used as the return stack. Most of the registers are 
	    used for temporary data in primitives.
         </para>
      </sect1>

      <sect1 id="Architecture_VM">
         <title>CPU -- Forth VM Mapping</title>
         <para>
            The default Forth registers are mapped as follows
            <table>
               <title>Register Mapping</title>
               <tgroup cols="2">
                  <thead>
                     <row>
                        <entry>Forth Register</entry>
                        <entry>ATmega Register(s)</entry>
                     </row>
                  </thead>
                  <tbody>
                     <row>
                        <entry>Word pointer W</entry>
                        <entry>R26:R27</entry>
                     </row>
                     <row>
                        <entry>Instruction Pointer IP</entry>
                        <entry>XH:XL</entry>
                     </row>
                     <row>
                        <entry>Return Stack Pointer RP</entry>
                        <entry>SPH:SPL</entry>
                     </row>
                     <row>
                        <entry>Data Stack Pointer SP</entry>
                        <entry>YH:YL</entry>
                     </row>
                  </tbody>
               </tgroup>
            </table>
            In addition the register pair ZH:ZL is used as temporary
            storage and as an operand in many operations.
         </para>

         <sect2>
            <title>Inner Interpreter</title>
            <para>
               The inner interpreter implements the indirect threading
               execution with an interrupt handling extension.
            </para>
            <sect3>
               <title>EXECUTE</title>
               <para>
                  Execute reads the address the IP currently points to
                  and jumps to it.
               </para>
            </sect3>
            <sect3>
               <title>NEXT</title>
               <para>
                  The NEXT routine is the core of the inner interpreter.
                  It performs two flash accesses, the second one is
                  accessed as EXECUTE.
               </para>

               <para>
                  The very first step in NEXT is to check whether an
                  interrupt needs to handled. It is done by looking at
                  the  <code>T</code>
                  flag in the machine status register. If it is set, the
                  code jumps to the interrupt handling part. If the flag
                  is cleared the normal NEXT routine is executed.
               </para>
            </sect3>
            <sect3>
               <title>NEST</title>
               <para>
                  NEST (or DO_COLON) pushes the current IP to the return
                  stack and loads the flash cell pointed to by the Word Pointer
                  into the IP. Then it continues with NEXT.
               </para>
            </sect3>
            <sect3>
               <title>UNNEST</title>
               <para>
                  The code for UNNEST is the word
                  <code>EXIT</code>
                  in the dictionary. It pops the IP from the
                  return stack and jumps to NEXT.
               </para>
            </sect3>
            <sect3>
               <title>DO_DOES</title>
               <para>
                  This code is the runtime that is used by the code
                  compiled by the forth word
                  <code>DOES</code>. It it closly tight to the action performed by the
                  code compiled by DOES. That code pushed the current
                  address in the data field to the returnstack and jumps
                  to DO_DOES. DO_DOES gets that address back, saves the
                  current IP and sets the forth IP to the address it got
                  from the stack. Finally it continues with NEXT.
               </para>
            </sect3>
         </sect2>
      </sect1>
      <sect1 id="Core_System">
         <title>Core System</title>

         <sect2>
            <title>Threading Model</title>
            <para>
               amforth uses the classic indirect threaded variant of
               forth.
            </para>
         </sect2>
         <sect2>
            <title>Stacks</title>
            <sect3>
               <title>Data Stack</title>
               <para>
                  The data stack uses the CPU register pair YH:YL as
                  it's data pointer. The Top-Of-Stack element (TOS) is
                  in a register pair. Compared to a straight forward
                  implementation this approach saves both code space and
                  gives higher execution speed (approx 10-20 %). Saving
                  more stack elements does not really give more
                  profit (much more code and only little speed
                  enhancements).
               </para>
               <para>
                  The data stack starts at a configurable distant below
                  the return stack (RAMEND) and grows downward.
               </para>
            </sect3>
            <sect3>
               <title>Return Stack</title>
               <para>
                  The Return Stack is the hardware stack of the
                  controller. It is managed with push/pop instructions.
                  The return stack starts at RAMEND und grows downward.
               </para>
            </sect3>
         </sect2>
         <sect2>
            <title>Interrupts</title>
            <para>
               amforth routes the low level interrupts into the forth
               inner interpreter. The inner interpreter switches the
               execution to a predefined word if an interrupt occurs.
               When that word finishes execution, the interrupted word
               is continued. The interrupt handlers are completly normal
               forth words without any stack effect.
            </para>

            <para>
               The processing of the interrupts takes two steps: The
               first one is responsible for the low level part. It is
               called whenever an interrupt occurs. The code is the same
               for all interrupts. It takes the number of the interrupt
               from it's vector address and stores this in a RAM cell.
               Then the low level ISR sets the
               <code>T</code>
               flag in the status register of the controller. The inner
               interpreter checks every time it is entered this flag and
               if it is set it switches to interrupt handling at forth
               level. This approach has an penalty of 2 CPU cycles for
               checking and skipping the branch instruction to the isr
               forth code.
            </para>

            <para>
               The ISR at forth level is a RAM based table much like the
               low level interrupt table of the exection tokens
               associated with the interrupt number.
            </para>

            <para>
               Interrupts from hardware sources (such as the usart) may
               not work as expected. The reason is that the interrupt
               source is not cleared within the generic ISR. This leads
               to an immediate re-interrupt. There is currently no
               solution but a custom ISR that clears the interrupt
               source and calls the main ISR. This code has to be run
               within the interrupt and cannot be (easily) turned into
               forth code, since the forth inner interpreter is not
               reentrant.
               <!-- maybe run an forth
                  interpreter in background to handle interrupts? -->
            </para>
         </sect2>
         <sect2>
            <title>Multitasking</title>
            <para>
               amforth does not really implement multitasking. It only
               provides the basic operation for it. Within the IO words
               the word <code>PAUSE</code>
               is called whenever possible. This word is as a deferred
               word that is initialized to do nothing (NOOP).
            </para>
         </sect2>

         <sect2>
            <title>Exception Handling</title>
            <para>
               amforth implements the CATCH/THROW exception handling.
               The outmost catch frame is located at the interpreter
               level in the word QUIT. If an exception with the value -1
               or -2 is throws, QUIT will print a message and re-start
               itself. Other values silently restart QUIT.
            </para>
         </sect2>
      </sect1>
      <sect1 id="Memory_Layout">
         <title>Memory Layout</title>

         <sect2>
            <title>Flash</title>
            <para>
               The flash memory is divided in 5 sections. The first
               section, starting at address 0, contains the interrupt
               vector table for the low level interrupt handling and a
               character string with the name of the controller in plain
               text.
            </para>

            <para>
               The next section is the initialization code block. It is
               executed whenever the controller starts. The code sets up
               the basic infrastructure for the forth interpreter. This
               step is finished by calling the forth interpreter with
               the word COLD as the entry word.
            </para>

            <para>
               The 3rd section contains the low level interrupt handling
               routines. The interrupt handler is very closly tight to
               the inner interpreter. It is located near the first
               section to use the faster relative jump instructions.
            </para>

            <para>
               The 4th section is the first part of the dictionary.
               Nearly all colon words are located here. New words are
               appended to this section. This section is filled with
               FFFF cells when flashing the controller initially.
            </para>

            <para>
               The last section is identical to the boot loader section
               of the ATmegas. It is also known as NRWW area. Here is
               the heart of amforth: The inner interpreter and most of
               the words coded in Assembly language.
            </para>

            <para>
               The reason for this split is a technical one: to work
               with a dictionary in flash the controller needs to write
               to the flash. The ATmega architecture provides a
               mechanism called self-programming by using a special
               instruction and a rather complex algorith. This
               instruction only works in the boot loader/NRWW section.
               amforth uses this instruction in the word I!. Due to the
               fact that the self programming is a lot more then only a
               simple instruction, amforth needs most of the forth core
               system to achieve it. A side effect is that amforth
               cannot co-exist with classic bootloaders. If a particular
               boot loader provides an API to enable applications call
               the flash write operation, amforth can be restructured to
               use it. Currently only very few and seldom used
               bootloaders exist that enable this feature.
            </para>
            <para>
               Atmegas can have more than 64 KB Flash. This requires
               more than 16 bit address bit, which is more than the cell
               size. For one type of those bigger atmegas there will be
               an solution with 16 bit cell size: Atmega128 Controllers.
               They can use the whole address range with an
               interpretation: The flash addresses are in fact not byte
               addresses but word addresses. Since amforth does not deal
               with bytes but cells it is possible to use the whole
               address range with a 16 bit cell. The Atmegas with 128
               KBytes Flash operate slightly slower since the address
               interpretation does need more code to access the flash
               (both read and write).
            </para>
            <para>
               The technique described above does not work for the
               Atmega256x. These controllers definitly need a bigger
               cell size: 17 bits (or more).
            </para>
            <sect3>
               <title>Flash Write</title>
               <para>
                  The word performing the actual flash write operation
                  is I! (i-store). This word takes the value and the
                  address of a single cell to be written to flash from
                  the data stack. The address is a word address, not a
                  byte address!
               </para>
               <para>
                  The flash write strategy follows Atmel's appnotes. The
                  first step is turning off all interrupts. Then the
                  affected flash page is read into the flash page
                  buffer. While doing the copying a check is performed
                  whether a flash erase cycle is needed. The flash erase
                  can be avoided if no bit is turned from 0 to 1. Only
                  if a bit is switched from 0 to 1 a flash page erase
                  operation has to be done. In the fourth step the new
                  flash data is written and the flash is set back to
                  normal operation and the interrupt flag is restored.
               </para>
               <para>
                  This write strategy ensures that the flash has minimal
                  flash erase cycles while extending the dictionary. In
                  addition it keeps the forth system simple since it
                  does not need to deal with page sizes or RAM based
                  buffers for dictionary operations.
               </para>
            </sect3>
         </sect2>
         <sect2>
            <title>EEPROM</title>
            <para>
               The build-in EEPROM contains vital dictionary pointer and
               other persistant data. They need only a few EEPROM cells.
               The remaining space is available for user programs. The
               easiest way to use EEPROM is the use of forth VALUEs.
               There intended design pattern (read often, write seldom)
               is like that for the tyoical EEPROM usage.
            </para>

            <para>
               Another use for EEPROM cells is to hold execution tokens.
               The default system uses this for the turnkey vector. This
               is a eeprom variable that reads and executes the XT at
               runtime. It is based on the DEFER/IS standard. To define
               a deferred word in the EEPROM use the Edefer defintion
               word. The standard word IS is used to put a new XT into
               the vector.
            </para>

            <para>
               Lowlevel space management is done through the the EDP
               variable. This is not a forth value but a EEPROM based
               variable. To read the current value an e@ operation must
               be used, changes are written back with e!. It contains
               the highest EEPROM address currently allocated. The name
               is based on the DP variable, which points to the highest
               dictionary address.
            </para>

         </sect2>
         <sect2>
            <title>RAM</title>
            <para>
               The RAM address space is divided into three sections: the
               first 32 addresses are the CPU registers. Above come the
               IO registers and extended IO registers and finally the
               RAM itself.
            </para>

            <para>
               amforth needs a few (real) RAM locations for it's
               internal data structures. The biggest part are the
               buffers for the terminal IO. RAM Memory is managed by the
               words VARIABLE and ALLOT.
            </para>

            <para>
               With amforth all three sections can be access using there
               RAM address. That makes ist quite easy to work with words
               like
               <code>C@</code>
               . The word
               <code>!</code>
               implements a LSB byte order: The lower part of the cell
               is stored at the lower address.
            </para>
            <para>
               For the RAM exists a word Rdefer which implements a
               deferred word, placed in RAM. As a special case
               implements the word Udefer a deferred word in the user
               area. To put a XT into them the word IS is used. This
               word is smart enough to distinguish between the varios
               xdefer definitions.
            </para>
            <sect3>
               <title>User Area</title>
               <para>
                  The User Area is a special RAM based storage area. It
                  contains the USER variables and the User deferred
                  definitions. The access is based upon the value of the
                  user pointer UP. It can be changed with the words UP!
                  and read with UP@. The UP itself is stored in a
                  register pair.
               </para>
               <para>
                  The size of the user area is defined at compile time
                  in the device definition section. This may change in
                  future versions.
               </para>
               <para>
                  The User Area contains both variables (BASE) and
                  deferred words for the terminal IO (EMIT, KEY, EMIT?,
                  KEY?, /KEY). Other pre-defined locations are the
                  HANDLER variable (needed for the exception handling)
                  and the addresses of the stack pointers for the
                  inactive tasks, if multitasking is implemented and
                  used.
               </para>
            </sect3>
         </sect2>
      </sect1>

   </chapter>

   <chapter id="Forth">
      <title>Forth Implementation</title>
      <sect1 id="ANS">
         <title>ANS Words</title>

         <para>
            amforth implements most or all words from the ANS word sets
            CORE, CORE EXT, EXCEPTION and DOUBLE NUMBERS. The words from
            the word sets LOCALS, BLOCKS, FILE-ACCESS and FLOATING-POINT
            are dropped completly.
         </para>

         <sect2 id="ANS_CORE">
            <title>Core and Core EXT</title>
            <para>
               From the CORE word set only the words >NUMBER, C, CHAR+,
               CHAR, ENVIRONMENT?, EVALUATE, MOVE are missing. From the
               CORE EXT the words C", COMPILE, , CONVERT, EXPECT, SPAN,
               PICK, RESTORE-INPUT, ROLL are not implemented.
            </para>
            <para>The following words have non-standard behavior</para>
            <para>
               words created with : are immediately visible. A earlier
               definition with the same name will never be accessible.
               Work around may be done with DEFER/IS.
            </para>
            <para>loop counters are checked on signed compares.</para>
         </sect2>
         <sect2 id="ANS_BLOCK">
            <title>Block</title>
            <para>
               amforth does not currently support block related words.
               Implementing them is on the roadmap.
            </para>
         </sect2>
         <sect2 id="ANS_DOUBLENUMBER">
            <title>Double Number</title>
            <para>
               Double cell numbers do work as aspected. Not all words
               are implemented and they cannot be entered or dot-ed
               directly however.
            </para>
         </sect2>
         <sect2 id="ANS_EXCEPTION">
            <title>Exception</title>
            <para>
               Exceptions are fully supported. The words ABORT and
               ABORT" use them internally.
            </para>

            <para>
               The THROW codes -1, -2 and -13 work as specified.
            </para>

            <para>
               The implementation is based upon a variable HANDLER which
               holds the current return stack pointer position. This
               variable is a USER variable.
            </para>
         </sect2>
         <sect2 id="ANS_FACILITY">
            <title>Facility</title>
            <para>
               The basic system uses the KEY? and EMIT? words as
               deferred words.
            </para>
            <para>
               The word MS is implemented as the word 1MS which busy
               waits almost exactly 1 millisecond. The calculation is
               based upon the frequency specified at compiletime.
            </para>

            <para>
               The words TIME&amp;DATE, EKEY, EKEY>CHAR are not
               implemented.
            </para>

            <para>
               To control a VT100 terminal the words AT-XY and PAGE are
               written in forth code. They emit the ANSI control codes
               according to the VT100 terminal codes.
            </para>
         </sect2>
         <sect2 id="ANS_FILEACCESS">
            <title>File Access</title>
            <para>
               amforth does not have filesystem support. It does not
               support any words from this word set.
            </para>
         </sect2>
         <sect2 id="ANS_FLOATINGPOINT">
            <title>Floating Point</title>
            <para>
               amforth does not currently support floating point
               numbers.
            </para>
         </sect2>
         <sect2 id="ANS_LOCALS">
            <title>Locals</title>
            <para>amforth does not currently support locals.</para>
         </sect2>
         <sect2 id="ANS_MEMORY">
            <title>Memory Allocation</title>
            <para>
               amforth does not support the words from the memory
               allocation word set.
            </para>
         </sect2>
         <sect2 id="ANS_PROGRAMMING">
            <title>Programming Tools</title>
            <para>
               Variants of the words .S ? and DUMP are implemented or
               can easily be done. The word SEE won't be supported since
               amforth highly uses an optimization strategy to strip
               forth headers whenever possible. The other reason for
               dropping SEE is that amforth is OpenSource software. If
               your vendor does not disclose the full source, let me
               know. He violates the GPL.
            </para>
            <para>STATE works as specified</para>
            <para>
               The word WORDS does not sort the word list and does not
               take care of screen sizes.
            </para>

            <para>
               The words CODE ;CODE and ASSEMBLER are not supported,
               amforth does not have an assembler.
            </para>

            <para>
               CS-ROLL, CS-PICK and AHEAD are not imlemented. The
               compiler words operate with the more traditional
               MARK/RESOLVE word pairs.
            </para>
            <para>
               FORGET is implemented but does not fully reset the
               dictionary state. The better way is using MARKER.
            </para>

            <para>An EDITOR is not implemented.</para>

            <para>[IF], [ELSE] and [THEN] are not implemented.</para>
         </sect2>
         <sect2 id="ANS_SEARCH">
            <title>Search Order</title>
            <para>
               amforth does not support word lists, so no words from the
               search word set are implemented.
            </para>
         </sect2>
         <sect2 id="ANS_STRING">
            <title>Strings</title>
            <para>SLITERAL, CMOVE> and /STRING are implemented.</para>
            <para>
               -TRAILING, BLANK, CMOVE, COMPARE and SEARCH are not
               implemented.
            </para>
         </sect2>
      </sect1>
      <sect1 id="AMFORTH">
         <title>amforth extensions</title>
         <sect2 id="AMFORTH_MCU">
            <title>MCU Access</title>
            <para>
               amforth provides wrapper words for the microcontroller
               words sleep and wdr (watch dog reset). To work properly,
               the MCU needs more configuration. amforth itself does not
               call these words.
            </para>
         </sect2>
         <sect2 id="AMFORTH_MEMORY">
            <title>Memory</title>
            <para>
               Atmega microcontroller have three different types of
               memory. RAM, EEPROM and Flash. The words @ and ! work on
               the RAM address space (which include IO Ports and the CPU
               register), the words e@ and e! operate on the EEPROM and
               i@ and i! deal with the flash memory. All these words
               transfer one cell (2 bytes) between the memory and the
               data stack. The address is always the native address of
               the target storage: byte-level for EEPROM and RAM,
               word-level for flash. Therefore the flash addresses
               64KWords == 128 KBytes address space.
            </para>

            <para>
               External RAM shares the normal RAM address space after
               initialization (which needs to be done within the turnkey
               action) it is accessible without further action.
            </para>

            <para>
               For RAM only exists the special word pair c@/c! which
               uses the lower byte of the Top-Of-Stack at transfer. The
               upper byte is either ignored or set to 0 (zero).
            </para>
            <para>
               All other types of external memory need special handling,
               which may be masked with the block word set.
            </para>
         </sect2>
         <sect2 id="AMFORTH_IO">
            <title>Input Output</title>
            <para>
               IO stands for terminal IO. amforth followes the simple
               terminal paradigm. A serial console is used. All IO is
               based upon the standard words EMIT/EMIT? and KEY/KEY?. In
               addition the word /KEY is used to signal the sender to
               stop. All these words are deferred words in the USER area
               and can be changed with the IS command.
            </para>
            <para>
               The predefined words use an interrupt driven IO with an
               buffer for input and output. They do not implement an
               handshake procedure (XON/XOFF or CTS/RTS). The default
               terminal device is USART0 (if more than one USART ports
               are available).
            </para>
            <para>
               The basic words include an call of the PAUSE command to
               enable the use of multitasking.
            </para>
            <para>
               Other IO is heavily based on the hardware connected to
               the microcontroller. Code exist to use LCD and TV
               devices. CAN, USB or I2C may be possible as well. Another
               use of the redirect feature is the following: consider
               some input data in external EEPROM (or SD-Cards). To read
               it, the words KEY and KEY? are redirected to fetch the
               data from them.
            </para>
         </sect2>
         <sect2 id="AMFORTH_STRING">
            <title>Strings</title>
            <para>
               Strings can be stored in two areas: RAM and FLASH. It is
               not possible to distinguish between the storage areas
               based on the addresses found on the data stack, it's up
               to the developer to keep track.
            </para>
            <para>
               Strings are usually stored as counted strings. Strings in
               flash are compressed: two consecutive bytes are placed
               into one flash cell. The standard word S" copies the
               string from the RAM into flash using the word S,.
            </para>
         </sect2>
      </sect1>
   </chapter>
   <chapter id="TODO_ROADMAP">
      <title>Todos And Roadmap</title>
      <sect1>
         <title>ANS Words</title>
         <para>
            Support for Blocks may be useful. It is not trivial to
            implement a standard 1KB block buffer on an Atmega with 1KB
            RAM at all. It can be useful to deploy block sizes smaller
            than 1KB to match the native block sizes of the attached
            storage devices: serial EEPROM may have 64 bytes, SD-Cards
            have 512 bytes.
         </para>
      </sect1>
      <sect1>
         <title>More Controller Types</title>
         <para>
            amforth works on the whole range of Atmegas. The only
            limiting factor is the flash size: amforth needs at least 7
            KB for itself and can address at most 128 KB. The ATmega256x may be
            supported with an change in the cell size from 2 to 3 bytes.
            The other possible devices are the XMega MCU, that Atmel may
            publish in the near future. ATiny are not supported since
            they lack both flash size and some instructions that amforth
            uses.
         </para>
      </sect1>
   </chapter>
   <!--  &REFCARD; -->
</book>

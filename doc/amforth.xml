<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [

<!ENTITY REFCARD SYSTEM "refcard.xml">

]>

<book>
   <bookinfo>
      <title>amforth - Forth for AVR ATmega mico controller</title>
      <titleabbrev>amforth</titleabbrev>
      <author>
         <personname>
            <firstname>Matthias</firstname>
            <surname>Trute</surname>
         </personname>
         <email>mtrute@users.sourceforge.net</email>
      </author>

      <pubdate>2007</pubdate>
      <copyright>
         <year>2007</year>
         <holder>Matthias Trute</holder>
      </copyright>
   </bookinfo>
   <toc />
   <chapter id="Overview">
      <title>Overview</title>
      <sect1 id="Introduction">
         <title>Introduction</title>
         <para>
            amforth is a Forth system for the AVR Atmega micro
            controller family. It works on the controller itself and
            does not depend on any additional hard- or software.
         </para>

         <para>
            amforth implements a large subset of the Forth standard
            ANS94. Most of the CORE words and a few from the varios
            extension word sets are implemented. The word set used in an
            actual implementation can easily be changed.
         </para>

         <para>
            The dictionary resides in the flash memory. The build-in
            compiler extends it directly.
         </para>

         <para>
            amforth gives full access to (almost) all interrupts. The
            interrupt handler routines are implemented as forth words.
         </para>

         <para>
            amforth is published under the GNU General Public License
            version 2.
         </para>

         <para>The name amforth has no special meaning.</para>
      </sect1>
      <sect1 id="History">
         <title>History</title>
         <para>
            amforth is a new implementaion. The first code was written
            in the summer of 2006. It is written "from scratch" using
            the assembly language and forth itself.
         </para>

         <para>
            The first lines of code were written with the AVR Studio and
            it's simulator. Soon the switch to real hardware (some
            evalation boards) and a linux based development was made.
            The source code is suitable for both the AVR Studio and the
            linux avr assembler avra url{avra.sourceforge.net}.
         </para>

      </sect1>

      <sect1 id="Hardware">
         <title>Fuses</title>
         <para>
            Amforth uses the self programming features of the ATmegas to
            extend the dictionary. It is ok to use the factory default
            settings plus changes for the oszillator settings.
            Everything else should be changed with great care.
         </para>
      </sect1>
   </chapter>


   <chapter id="Architecture">
      <title>Architecture</title>
      <sect1 id="Architectur_Overview">
         <title>Overview</title>

         <para>
            amforth is a 16 bit Forth implementing the indirect
            threading model. The flash memory contains the whole
            dictionary. Some EEPROM cells are used to hold initial
            values. The RAM contains buffers, variables and the stacks.
         </para>

         <para>
            The compiler is a classic do-and-forget compiler without any
            kind of optimization.
         </para>

         <para>
            amforth uses most of the CPU registers to hold vital data
            structures: The data stack pointer, the instruction pointer,
            the user pointer, and the Top-Of-Stack cell. The hardware
            stack is used as the return stack. Some registers are used
            for temporary data in primitives.
         </para>
      </sect1>

      <sect1 id="Architecture_VM">
         <title>CPU -- Forth VM Mapping</title>
         <para>
            The Forth virtual machine uses the indirect theading model.
            The default Forth registers are mapped as follows
            <table>
               <title>Register Mapping</title>
               <tgroup cols="2">
                  <thead>
                     <row>
                        <entry>Forth Register</entry>
                        <entry>ATmega Register(s)</entry>
                     </row>
                  </thead>
                  <tbody>
                     <row>
                        <entry>Word pointer W</entry>
                        <entry>R26:R27</entry>
                     </row>
                     <row>
                        <entry>Instruction Pointer IP</entry>
                        <entry>XH:XL</entry>
                     </row>
                     <row>
                        <entry>Return Stack Pointer RP</entry>
                        <entry>SPH:SPL</entry>
                     </row>
                     <row>
                        <entry>Data Stack Pointer DP</entry>
                        <entry>YH:YL</entry>
                     </row>
                  </tbody>
               </tgroup>
            </table>
            In addition the register pair ZH:ZL is used as a temporary
            storage.
         </para>

         <sect2>
            <title>Inner Interpreter</title>
            <para>
               The inner interpreter implements the indirect threading
               execution with an interrupt handling extension.
            </para>
            <sect3>
               <title>EXECUTE</title>
               <para>
                  Execute reads the address the IP currently points to
                  and jumps to it.
               </para>
            </sect3>
            <sect3>
               <title>NEXT</title>
               <para>
                  The NEXT routine is the core of the inner interpreter.
                  It performs two flash accesses, the second one is
                  accessed as EXECUTE.
               </para>

               <para>
                  The very first step in NEXT is to check whether an
                  interrupt needs to handled. It is done by looking at
                  the
                  <code>T</code>
                  flag in the machine status register. If it is set, the
                  code jumps to the interrupt handling part. If the flag
                  is cleared the normal NEXT routine runs.
               </para>
            </sect3>
            <sect3>
               <title>NEST</title>
               <para>
                  NEST (or DO_COLON) pushes the current IP to the return
                  stack and loads the next flash from the Word Pointer
                  into the IP. Then it continues with NEXT.
               </para>
            </sect3>
            <sect3>
               <title>UNNEST</title>
               <para>
                  The code for UNNEST is the word
                  <code>EXIT</code>
                  in the dictionary. It simply pops the IP from the
                  return stack and jumps to NEXT.
               </para>
            </sect3>
            <sect3>
               <title>DO_DOES</title>
               <para>
                  This code is the runtime that is used by the code
                  compiled by the forth word
                  <code>DOES</code>
                  . It it closly tight to the action performed by the
                  code compiled by DOES. That code pushed the current
                  address in the data field to the returnstack and jumps
                  to DO_DOES. DO_DOES gets that address back, saves the
                  current IP and sets the forth IP to the address it got
                  from the stack. Finally it continues with NEXT.
               </para>
            </sect3>
         </sect2>
      </sect1>
      <sect1 id="Core_System">
         <title>Core System</title>

         <sect2>
            <title>Threading Model</title>
            <para>
               amforth uses the indirect (classic) threaded variant of
               forth.
            </para>
         </sect2>
         <sect2>
            <title>Stacks</title>
            <sect3>
               <title>Data Stack</title>
               <para>
                  The data stack uses the CPU register pair YH:YL as
                  it's data pointer. The Top-Of-Stack element (TOS) is
                  in a register pair. Compared to a straight forward
                  implementation this approach saves both code space and
                  gives higher execution speed. Saving more stack
                  elements does not really give any more profit (much
                  more code and only little speed enhancements).
               </para>
               <para>
                  The data stack starts at a configurable distant below
                  the return stack (RAMEND) and grows downward.
               </para>
            </sect3>
            <sect3>
               <title>Return Stack</title>
               <para>
                  The Return Stack is the hardware stack of the
                  controller. It is managed with push/pop instructions.
                  The return stack starts at RAMEND und grows downward.
               </para>
            </sect3>
         </sect2>
         <sect2>
            <title>Interrupts</title>
            <para>
               amforth routes the low level interrupts into the forth
               inner interpreter. The inner interpreter switches the
               execution to a predefined word if an interrupt occurs.
               When that word finishes execution, the interrupted word
               is continued. The interrupt handlers are completly normal
               forth words without any stack effect.
            </para>

            <para>
               The processing of the interrupts takes two steps: The
               first one is responsible for the low level part. It is
               called whenever an interrupt occurs. The code is the same
               for all interrupts. It takes the number of the interrupt
               from it's vector address and stores this in a RAM cell.
               Then the low level ISR sets the
               <code>T</code>
               flag in the status register of the controller. The inner
               interpreter checks every time it is entered this flag and
               if it is set it switches to interrupt handling at forth
               level. This approach has an penalty of 2 CPU cycles for
               checking and skipping the branch instruction to the isr
               forth code.
            </para>

            <para>
               The ISR at forth level is a RAM based table much like the
               low level interrupt table of the exection tokens
               associated with the interrupt number.
            </para>

            <para>
               Interrupts from hardware sources (such as the usart) may
               not work. The reason is that the interrupt source is not
               cleared within the generic ISR. This leads to an
               immediate re-interrupt. There is currently no solution
               but a custom ISR that clears the interrupt source and
               calls the main ISR. This code has to be run within the
               interrupt and cannot be (easily) turned into forth code,
               since the forth inner interpreter is not reentrant.
               <!-- maybe run an forth
                  interpreter in background to handle interrupts? -->
            </para>
         </sect2>
         <sect2>
            <title>Multitasking</title>
            <para>
               amforth does not really implement multitasking. It only
               provides the basic framework for it. Within the IO words
               the word PAUSE is called whenever possible. This word is
               as a deferred word that is initialized to do nothing
               (NOOP).
            </para>
         </sect2>

         <sect2>
            <title>Exception Handling</title>
            <para>
               amforth implements the CATCH/THROW exception handling.
               The outmost catch frame is located at the interpreter
               level in the word QUIT. If an exception with the value -1
               or -2 is throws, QUIT will print a message and re-start
               itself. Other values silently restart QUIT.
            </para>
         </sect2>
      </sect1>
      <sect1 id="Memory_Layout">
         <title>Memory Layout</title>

         <sect2>
            <title>Flash</title>
            <para>
               The flash memory is divided in 5 sections. The first
               section, starting at address 0, contains the interrupt
               vector table for the low level interrupt handling and a
               character string with the name of the controller in plain
               text.
            </para>

            <para>
               The next section is the initialization code block. It is
               executed whenever the controller starts. The code sets up
               the basic infrastructure for the forth interpreter. This
               step is finished by calling the forth interpreter with
               the word COLD as the entry word.
            </para>

            <para>
               The 3rd section contains the low level interrupt handling
               routines. The interrupt handler is very closly tight to
               the inner interpreter. It is located near the first
               section to use the faster relative jump instructions.
            </para>

            <para>
               The 4th section is the first part of the dictionary.
               Nearly all colon words are located here. New words are
               appended to this section. This section is filled with
               FFFF cells when flashing the controller initially.
            </para>

            <para>
               The last section is identical to the boot loader section
               of the ATmegas. It is also known as NRWW area. Here is
               the heart of amforth: The inner interpreter and most of
               the words coded in Assembly language.
            </para>

            <para>
               The reason for this split is a technical one: to work
               with a dictionary in flash the controller needs to write
               to the flash. The ATmega architecture provides a
               mechanism called self-programming by using a special
               instruction and a rather complex algorith. This
               instruction only works in the boot loader/NRWW section.
               amforth uses this instruction in the word I!. Due to the
               fact that the self programming is a lot more then only a
               simple instruction, amforth needs most of the forth core
               system to achieve it. A side effect is that amforth
               cannot co-exist with classic bootloaders. If a particular
               boot loader provides an API to enable applications call
               the flash write operation, amforth can be restructured to
               use it. Currently only very few and seldom used
               bootloaders exist that enable this feature.
            </para>
            <para>
               Atmegas can have more than 64 KB Flash. This requires
               more than 16 bit address bit, which is more than the cell
               size. For one type of those bigger atmegas there will be
               an solution with 16 bit cell size: Atmega128 Controllers.
               They can use the whole address range with an
               interpretation: The flash addresses are in fact not byte
               addresses but word addresses. Since amforth does not deal
               with bytes but cells it is possible to use the whole
               address range with a 16 bit cell. The Atmegas with 128
               KBytes Flash operate slightly slower since the address
               interpretation does need more code to access the flash
               (both read and write).
            </para>
            <para>
               The technique described above does not work for the
               Atmega256x. These controllers definitly need a bigger
               cell size: 17 bits (or more).
            </para>
            <sect3>
               <title>Flash Write</title>
               <para>
                  The word performing the actual flash write operation
                  is I! (i-store). This word takes the value and the
                  address of a single cell to be written to flash from
                  the data stack. The address is a word address, not a
                  byte address!
               </para>
               <para>
                  The flash write strategy follows Atmel's appnotes. The
                  first step is turning off all interrupts. Then the
                  affected flash page is read into the flash page
                  buffer. While doing the copying a check is performed
                  whether a flash erase cycle is needed. The flash erase
                  can be avoided if no bit is turned from 0 to 1. Only
                  if a bit is switched from 0 to 1 a flash page erase
                  operation has to be done. In the fourth step the new
                  flash data is written and the flash is set back to
                  normal operation and the interrupt flag is restored.
               </para>
               <para>
                  This write strategy ensures that the flash has minimal
                  flash erase cycles while extending the dictionary. In
                  addition it keeps the forth system simple since it
                  does not need to deal with page sizes or RAM based
                  buffers for dictionary operations.
               </para>
            </sect3>
         </sect2>
         <sect2>
            <title>EEPROM</title>
            <para>
               The build-in EEPROM contains vital dictionary pointer and
               other persistant data. They need only a few EEPROM cells.
               The remaining space is available for user programs. The
               easiest way to use EEPROM is the use of forth VALUEs.
               There intended design pattern (read often, write seldom)
               is like that for the tyoical EEPROM usage.
            </para>

            <para>
               Another use for EEPROM cells is to hold execution tokens.
               The default system uses this for the turnkey vector. This
               is a eeprom variable that reads and executes the XT at
               runtime. It is based on the DEFER/IS standard. To define
               a deferred word in the EEPROM use the Edefer defintion
               word. The standard word IS is used to put a new XT into
               the vector.
            </para>

            <para>
               Lowlevel space management is done through the the EDP
               variable. This is not a forth value but a EEPROM based
               variable. To read the current value an e@ operation must
               be used, changes are written back with e!. It contains
               the highest EEPROM address currently allocated. The name
               is based on the DP variable, which points to the highest
               dictionary address.
            </para>

         </sect2>
         <sect2>
            <title>RAM</title>
            <para>
               The RAM address space is divided into three sections: the
               first 32 addresses are the CPU registers. Above come the
               IO registers and extended IO registers and finally the
               RAM itself.
            </para>

            <para>
               amforth needs a few (real) RAM locations for it's
               internal data structures. The biggest part are the
               buffers for the terminal IO. RAM Memory is managed by the
               words VARIABLE and ALLOT.
            </para>

            <para>
               With amforth all three sections can be access using there
               RAM address. That makes ist quite easy to work with words
               like
               <code>C@</code>
               . The word
               <code>!</code>
               implements a LSB byte order: The lower part of the cell
               is stored at the lower address.
            </para>
            <para>
               For the RAM exists a word Rdefer which implements a
               deferred word, placed in RAM. As a special case
               implements the word Udefer a deferred word in the user
               area. To put a XT into them the word IS is used. This
               word is smart enough to distinguish between the varios
               xdefer definitions.
            </para>
            <sect3>
               <title>User Area</title>
               <para>
                  The User Area is a special RAM based storage area. It
                  contains the USER variables and the User deferred
                  definitions. The access is based upon the value of the
                  user pointer UP. It can be changed with the words UP!
                  and read with UP@. The UP itself is stored in a
                  register pair.
               </para>
               <para>
                  The size of the user area is defined at compile time
                  in the device definition section. This may change in
                  future versions.
               </para>
               <para>
                  The User Area contains both variables (BASE) and
                  deferred words for the terminal IO (EMIT, KEY, EMIT?,
                  KEY?, /KEY). Other pre-defined locations are the
                  HANDLER variable (needed for the exception handling)
                  and the addresses of the stack pointers for the
                  inactive tasks, if multitasking is implemented and
                  used.
               </para>
            </sect3>
         </sect2>
      </sect1>

   </chapter>

   <chapter id="Forth">
      <title>Forth Implementation</title>
      <sect1 id="ANS">
         <title>ANS Words</title>

         <para>
            amforth implements most or all words from the CORE and CORE
            EXT word sets. The words from the word sets LOCALS, BLOCKS,
            FILE-ACCESS and FLOATING-POINT are dropped completly.
         </para>

         <sect2 id="ANS_CORE">
            <title>Core and Core EXT</title>
            <para>
               From the CORE word set only the words >NUMBER, C, CHAR+,
               CHAR, ENVIRONMENT?, EVALUATE, MOVE are missing. From the
               CORE EXT the words C", COMPILE, , CONVERT, EXPECT, SPAN,
               PICK, RESTORE-INPUT, ROLL are not implemented.
            </para>
            <para>The following words have non-standard behavior</para>
            <para>
               words created with : are immediately visible. A earlier
               definition with the same name will never be accessible.
               Work around may be done with DEFER/IS.
            </para>
            <para>loop counters are checked on signed compares.</para>
         </sect2>
         <sect2 id="ANS_BLOCK">
            <title>Block</title>
            <para>
               amforth does not currently support block related words.
               Implementing them is on the roadmap.
            </para>
         </sect2>
         <sect2 id="ANS_DOUBLENUMBER">
            <title>Double Number</title>
            <para>
               Double numbers are partially supported. They cannot be
               entered directly.
            </para>
         </sect2>
         <sect2 id="ANS_EXCEPTION">
            <title>Exception</title>
            <para>
               Exceptions are fully supported. The central words THROW
               and CATCH can be used. The words ABORT and ABORT" use
               them internally.
            </para>

            <para>
               The THROW codes -1, -2 and -13 are used as specified.
            </para>

            <para>
               The implementation is based upon a variable HANDLER which
               holds the current return stack pointer position. This
               variable is a USER variable.
            </para>
         </sect2>
         <sect2 id="ANS_FACILITY">
            <title>Facility</title>
            <para>
               The basic system uses the KEY? and EMIT? words as
               deferred words (see ).
            </para>
            <para>
               The word MS is implemented as the word 1MS which busy
               waits almost exactly 1 millisecond. The calculation is
               based upon the frequency specified at compiletime.
            </para>

            <para>
               The words TIME&amp;DATE, EKEY, EKEY>CHAR are not
               implemented.
            </para>

            <para>
               To control a VT100 terminal the words AT-XY and PAGE are
               written in forth code. They emit the ANSI control codes
               according to the VT100 terminal codes.
            </para>
         </sect2>
         <sect2 id="ANS_FILEACCESS">
            <title>File Access</title>
            <para>
               amforth does not have filesystem support. It does not
               support any words from this word set.
            </para>
         </sect2>
         <sect2 id="ANS_FLOATINGPOINT">
            <title>Floating Point</title>
            <para>
               amforth does not currently support floating point
               numbers.
            </para>
         </sect2>
         <sect2 id="ANS_LOCALS">
            <title>Locals</title>
            <para>amforth does not currently support locals.</para>
         </sect2>
         <sect2 id="ANS_MEMORY">
            <title>Memory Allocation</title>
            <para>
               amforth does not support the words from the memory
               allocation word set.
            </para>
         </sect2>
         <sect2 id="ANS_PROGRAMMING">
            <title>Programming Tools</title>
            <para>
               Variants of the words .S ? and DUMP are implemented or
               can easily be done. The word SEE won't be supported since
               amforth highly uses an optimization strategy to strip
               forth headers whenever possible. The other reason for
               dropping SEE is that amforth is OpenSource software. If
               your vendor does not disclose the full source, let me
               know. He violates the GPL.
            </para>
            <para>STATE works as specified</para>
            <para>
               The word WORDS does not sort the word list and does not
               take care of screen sizes.
            </para>

            <para>
               The words CODE ;CODE, ASSEMBLER are not supported,
               amforth does not have an assembler.
            </para>

            <para>
               CS-ROLL, CS-PICK and AHEAD are not imlemented. The
               compiler words operate with the more traditional
               MARK/RESOLVE word pairs.
            </para>
            <para>
               FORGET is implemented but does not fully reset the
               dictionary state. The better way is using MARKER.
            </para>

            <para>EDITOR is not implemented.</para>

            <para>[IF], [ELSE] and [THEN] are not implemented.</para>
         </sect2>
         <sect2 id="ANS_SEARCH">
            <title>Search Order</title>
            <para>
               amforth does not support word lists, so no words from the
               search word set are implemented.
            </para>
         </sect2>
         <sect2 id="ANS_STRING">
            <title>String</title>
            <para>SLITERAL, CMOVE> and /STRING are implemented.</para>
            <para>
               -TRAILING, BLANK, CMOVE, COMPARE and SEARCH are not
               implemented.
            </para>
         </sect2>
      </sect1>
      <sect1 id="AMFORTH">
         <title>amforth extensions</title>
         <sect2 id="AMFORTH_MEMORY">
            <title>Memory</title>
            <para></para>
         </sect2>
         <sect2 id="AMFORTH_IO">
            <title>Input Output</title>
            <para></para>
         </sect2>
      </sect1>
   </chapter>
   <chapter id="TODO_ROADMAP">
      <title>Todos And Roadmap</title>
      <sect1>
         <title>ANS Words</title>
         <para>
            Support for Blocks may be useful. It is not trivial to
            implement a standard 1KB block buffer on an Atmega with 1KB
            RAM at all. It can be useful to deploy block sizes smaller
            than 1KB to match the native block sizes of the attached
            storage devices: serial EEPROM may have 64 bytes, SD-Cards
            have 512 bytes.
         </para>
      </sect1>
      <sect1>
         <title>More Controller Types</title>
         <para>
            amforth works on the whole range of Atmegas. The only
            limiting factor is the flash size: amforth needs at least 7
            KB for itself and can address at most 128 KB. The ATmega256x
            may be supported with an change in the cell size from 2 to 3
            bytes. The other devices are the XMega MCU, that Atmel may
            publich in the near future.
         </para>
        </sect1>
   </chapter>
   <!--  &REFCARD; -->
</book>
